# 数据密集型应用系统设计

## 前言

后端开发数据的高效存储和数据处理是核心主题。

数据密集型指的是数据的规模，数据的复杂度，数据产生和变化的速率

从书中能获得什么，对哪些技术涉及到哪些场景，常见工具如何搭配来构建应用系统。

书中涉及到的数据处理技术包括NoSQL系统、消息队列、缓存、搜索引擎、批处理和流处理框架

## 数据系统基础

### 第一章 可靠性、可维护性、可扩展性的应用系统

应用系统都包含以下模块，需要了解这些模块的性能特征和设计实现：

- 数据库：用以存储数据。
- 高速缓存：缓存那些复杂或操作代价昂贵的结果。
- 索引：用户可以按关键字搜索数据并支持各种过滤。
- 流式处理：持续发送消息至另一个进程，处理采用异步方法。
- 批处理：定期处理大量的累积数据。

#### 认识数据系统

当系统的需求广泛时，需要用到多个模块的组合，基于一个个较小的、通用的组件构建成一个全新的、专用的数据系统。

影响数据系统设计的因素有很多，大多数软件系统都极为重要的三个问题：

- 可靠性：容忍硬件，软件失效，人为错误
- 可扩展性：系统以合理的方式应对数据的增长
- 可维护性：可运维，简单与可演化性

#### 可靠性

容错总是指特定类型的故障，这样的讨论才有实际意义。

故障和失效不完全一致，故障通常定义为组件偏离其正常规格，而失效意味着系统作为一个整体停止，无法向用户提供所需的服务。我们要做的是设计容错机制来避免从故障引发系统失效，即在不可靠组件的基础上构建可靠性系统。

在这种容错系统中，用于测试目的，可以故意提高故障发生的概率，例如通过随机杀死某个进程。比如Choas Monkey就是这种测试工具。

##### 硬件故障

当系统有很多台机器时，硬件故障发生的概率也会随之增大，通过硬件冗余的方案来减少系统故障率。

硬件冗余使得单台机器完全失效的概率降为非常低的水平。

用软件容错的方式来容忍多机失效，滚动升级。

##### 软件错误

硬件故障之间多是相互独立的，而软件故障是相互关联的，往往会导致更多的系统故障。

- 软件错误，导致输入特定值时服务器总是崩溃
- 应用进程使用了某些共享资源如CPU、内存、磁盘或网络带宽
- 系统依赖于某些服务，服务忽然变慢或者无响应。
- 级联故障

认真检查依赖的假设条件和系统之间的交互，全面测试，进程隔离，进程崩溃自动重启

##### 人为失误

- 用最小出错的方式来设计系统
- 充分测试
- 快速恢复机制
- 详细而清晰的监控子系统

#### 可扩展性

负载增加，系统仍要能可靠地工作。可扩展性是描述系统应对负载增加能力的术语，对可扩展性的讨论应该围绕“如果系统以某种方式增长，我们应对增长的措施有哪些”

##### 描述负载

引入负载参数来描述负载，可能是web服务器每秒请求处理次数，数据库中写入的比例，活跃用户数量，缓存命中率。

Twitter设计的例子

考虑发布tweet消息和查看主页时间线两个功能点，Twitter的扩展性的重点不在于其消息的大小，而在于其巨大的扇出结构，一个用户可能被多个人关注，一个用户也可以关注很多人。有两种解决方案。

用关系型数据模型来支持时间线

![image-20220313162649103](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220313162649103.png)

用数据流水线的方式来推送tweet

![image-20220313162731712](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220313162731712.png)

这种方法的问题是如果一个用户有很多的关注者（3000万），那么他发一条消息意味着大量的写入，这是一个巨大的挑战。

现在的推特更倾向于两种方式向结合，对普通用户用数据流水线的方式，对名人用户用关系模型。

##### 描述性能

负载增加，如果系统资源不变保持不变，系统性能将发生什么变化？

负载增加，如果要保持性能不变，需要增加多少资源？

如何描述系统性能，

批处理系统：吞吐量，每秒可处理的记录条数。在指定数据集上运行作业所需的总时间。

在线系统：服务的响应时间，从客户端发送请求到接收响应之间的间隔。

即使反复执行相同的请求每次也可能产生不同的响应时间，因此应该将响应时间看做是一种可度量的数值分布。可以用平均响应时间，百分位数（中位数就是50百分位数，缩写为p50）来描述这种分布。

为了弄清楚异常值有多糟糕，常见的更大的百分位数有95，99，99.9

排队时延往往在高百分数响应时间中影响很大，服务器并行处理的能力有限，先前请求阻挡后续请求，发生队头阻塞，客户端体验极慢。

负载生成端要独立于响应时间来持续地发送请求。如果客户端在发送请求之前总是等待先前请求的完成，就会缩短服务器端累计排队的深度。

##### 应对负载增加的方法

实践中的百分位数，一次完整的服务包含了多次请求调用，最慢的请求处理会拖累整个系统。

将响应时间百分位数添加到服务系统监控中，持续跟踪该指标。比如，设置一个10min的滑动窗口的大小。

针对特定级别负载而设计的架构不可能应付超过预设目标10倍的实际负载。

垂直扩展，水平扩展（无共享体系结构）

系统如果具有弹性特征，可以自动检测负载增加，然后自动添加更多计算资源，如果系统负载高度不可预测，自动弹性系统会更加高效。手动方式可以减少执行期间的意外情况。

把无状态服务扩展至多台机器相对比较容易，而有状态服务的扩展则较为困难。

针对具体的特定应用定制不同的架构方案，需要考虑的因素有数据的读取量，写入量，待存储的数据量，数据的复杂程度，响应时间要求，访问模式。

吞吐量：每秒处理100000次请求（每个大小为1KB），每分钟三个请求（每个大小为2GB）

#### 可维护性

可运维性：方便运营团队来保持系统平稳运行。理解运维在做什么，数据系统可以为可运维性贡献什么。

简单性：简化系统复杂性，增加可理解性。复杂性是一种“意外”，是系统本身的问题，用抽象的方法来解决。

可演化性：可延伸性、易修改性、可塑性。适应需求的变化，敏捷开发技术。本书在更大的数据系统层面上提高敏捷性，系统由多个不同特征的应用或者服务协作而成，例如Twitter的案例。

### 第二章 数据模型与查询语言

大多数应用程序都是通过叠加数据模型来构建的。每一层面临的关键问题都是如何将其用下一层来表示。每层都提供一个简洁的数据模型来隐藏下层的复杂性

- 应用程序开发人员，观测现实世界，通过对象和数据结构，以及操作这些数据结构的API来进行建模。
- 需要存储这些数据结构时，可以采用**通用数据模型**（JSON或XML文档，关系数据库中的表和图模型）来表示。
- 数据库工程师接着决定用何种内存、磁盘或网络上的字节格式来表示上诉JSON/XML/关系/图形数据。数据表示需要支持多种方式的**查询、搜索、操作和处理数据**。
- 硬件工程师用电流、光脉冲、磁场等来表示字节。

#### 关系模型和文档模型

关系模型中数据被组织成关系，在SQL中称为表，每个关系都是元组（tuples在SQL中称为行）的无序集合。

关系数据库主要是用于事务处理（包括输入销售和银行交易、航空公司订票、仓库库存）和批处理（客户发票，工资单，报告）

#### NoSQL的诞生

非关系型数据库和关系型数据库一起使用，混合持久化。

- 比关系数据库有更好的扩展性需求，支持超大数据集和写入吞吐量。
- 免费开源
- 关系型数据库不能很好地支持一些特定的查询操作
- 不满于对关系模式的一些限制性

#### 对象关系不匹配

数据存储在关系表中，应用层代码中的对象和表、行和列的数据库模型之间需要一个笨拙的转换层【对象-关系（ORM）框架】。

在关系模式中表示简历，整个简历可以通过唯一的标识符user_id来标识。first name 和last name 这样的字段在每个用户中只出现一次，可以将其建模为users中的列。大多数人在他们的职业中有一个以上的工作。存在一对多的关系（多值属性）。有以下几种解决的方法：

- 在传统的SQL模型中，将职业放在单独的表中通过外键来引用users表。
- SQL标准增加了对结构化数据类型和XML数据的支持。
- 将工作，教育和联系信息编码为JSON或XML文档，JSON更加简单，面向文档的数据库都支持该数据类型。

缺乏模式的JSON模型减少了应用代码和存储层之间的阻抗失配。

JSON比多表模式具有更好的局部性，用户简历到用户的职位、教育历史和联系信息的一对多关系表示数据存在树状结构。

#### 多对一和多对多的关系

对于region和industry使用id而不是直接存储字符串可以消除对人类有直接意义信息的多次重复，防止对人类有意义的信息被修改所有冗余副本也都需要修改。消除重复也是数据库规范化的核心思想。

规范化会需要表达一对多的关系（许多人生活在同一地区，许多人在同一行业工作），这种方式不合适文档模型，而关系型数据库可以用连接来方便地表达。

如果数据库本身不支持联结，则必须在应用层中，通过对数据库的多次查询来模拟联结。

即使应用初始版本非常适合采用无联结的文档模型，在之后也可能不再适合

组织和学校作为实体，增加推荐人信息

![image-20220315164948283](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220315164948283.png)

在虚线框中的数据可以组织成一个文档，但是指向组织、学校以及其他用户的关系则需要表示为引用，在查询时需要联结操作。

#### 文档数据库vs关系数据库

层次模型：将所有数据表示为**嵌套**在记录中的记录。需要手动解析记录之间的引用或者复制多份数据。

网络模型：层次模型的推广。在层次模型的树结构中，每个记录只有一个父节点，在网络模型中，一个记录可能有多个父节点，例如“大西雅图地区“可能有一个记录，居住在该地区的每个用户都链接指向它。**访问**记录的唯一方法是选择一条始于根记录的**路径**。

关系模型：

定义了数据的格式，关系是元组的集合

关系型数据库中查询优化器决定以何种顺序进行查询，以及使用哪些索引

关系模型的一个核心要点是：只需构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中获益。

#### 与文档数据库的比较

文档数据库是层次模型，父记录中保存了嵌套记录。

表示多对一和多对多的关系时，关系数据库和文档数据库没有根本的不同，相关性由唯一的标识符引用。标识符在关系模型中被称为外键，在文档模型中被称为文档引用。

文档数据库的优点：

- 模式灵活性
- 由于局部性带来的较好的性能

关系模型的优点：

- 联结操作
- 多对一和一对多关系更简洁的表达

高度关联的数据用文档数据库不合适，文档数据库需要在应用层去模拟联结操作，或者通过反规范化来减少对联结的需求（需要维护数据的一致性）。

**文档模型中的模式灵活性**

文档数据库不会对文档中的数据强制执行任何模式，没有模式意味着可以将任意的key-value值添加到文档中，在读取时，客户端无法保证文档可能包含哪些字段。

文档数据库的无模式指的是读时模式，数据的结构是隐式的，只有读取时才解释。

写时模式，数据库确保数据写入时遵循一定的模式。

当应用程序需要改变数据格式时，比如把全名拆分为名字和姓氏，文档数据库，只需使用新字段来编写新文档，并在应用层来处理读取旧文档的情况。而静态类型数据库中需要对模式进行升级，比如ALTER TABLE，UPDATE，耗时较多。

当记录具有相同的结构，且结构稳定时，模式可以很好地确保这种结构，反之，无模式文档是更好的选择。

**查询数据的局部性**

文档通常存储为连续字符串而关系型数据库数据分在多个表中，需要多次索引查找，IO开销大。

局部性优势适用于同时访问文档大部分内容的场景，对文档进行更新时通常会重写整个文档，因此文档应该尽量小且避免写入时增加文档大小。关系模型中也利用了局部性。

**文档数据库和关系数据库的融合**

- 关系型数据库支持XML和JSON
- 文档数据库，查询接口支持和关系型数据库类似的联结，MongoDB的驱动解析数据库的引用关系

#### **数据查询语言**

声明式查询语言VS命令式查询语言

命令式语言告诉计算机以特定顺序执行某些操作。

声明式查询语言，只需指定所需的数据模式，不需要指明如何实现，查询优化器会执行。

- 声明式语言隐藏了实现数据库引擎的实现细节，数据库系统能够在不改变查询语句的情况下提高性能。
- 声明式语言适合于并行执行

#### web上的声明式查询

XSL和CSS属于web上的声明式查询，JavaScript属于命令式查询。

#### MapReduce查询

是一种编程模型，用于在很多机器上批量处理海量数据，一些NoSQL（MongoDB、CouchDB）支持有限的MapReduce方式在大量文档上执行只读查询。

MapReduce不是声明式查询语言也不是一个完全命令式的查询API，介于两种之间：查询逻辑用代码片段来表示，这些代码片段可以被处理框架重复地调用（MongoDB每个文档调用一次）。

上述方法的一个可用性问题是，必须编写两个密切协调的JavaScript函数。

MongoDB增加了称为聚合管道的声明式查询语言支持,聚合管道在表达能力上相当干SQL的子集，只不过使用了JSON的语法。

![image-20220316163716123](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220316163716123.png)

