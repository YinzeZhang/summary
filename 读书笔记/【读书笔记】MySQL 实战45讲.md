# MySQL 实战45讲

## 01 ｜ 基础架构：一条SQL查询语句是如何执行的？

```mysql
select * from T where ID = 10;
```

以上面的语句为例，分析一条SQL语句的执行过程，从而在MySQL遇到异常时快速定位问题。

MySQL基本架构示意图，从中可以看出SQL语句在MySQL的各个功能模块中的执行过程

![image-20220313120416122](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220313120416122.png)

MySQL可以分为**Server层**和**存储引擎层**两部分

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持**InnoDB**、MyISAM、 Memory等多个存储引擎。

### 连接器

要查询数据首先要和服务器建立连接，连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的:

```mysql
mysql -h$ip -P$port -u$user -p
```

如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序 结束执行。

如果用户名密码认证通过，连接器会到权限表里面查出你拥有的**权限**。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。

连接完成后，如果没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这 一行，就表示现在系统里面有一个空闲连接。

![image-20220313121805209](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220313121805209.png)

客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制 的，默认值是8小时。

如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒: Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。

数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

长连接后，可能会发现，MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中**使用的临时内存**是**管理**在**连接对象**里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现 象看就是MySQL异常重启了。

解决方案：

- 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
- 如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 **mysql_reset_connection**来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是 查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客 户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存 中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结 果，这个效率会很高。

建议不要使用查询缓存，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空，对于更新压力大的数据库 来说，查询缓存的命中率会非常低。

好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成 DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定，像下面这个语句一样:

```mysql
select SQL_CACHE * from T where ID=10;
```

MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。

### 分析器

分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识 别出里面的字符串分别是什么，代表什么。你输入的"select"这个关键字识别出来，这是一个查询语句，它也要把字符串“T”识别 成“表名T”，把字符串“ID”识别成“列ID”。

再做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法。

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)

的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join:

```mysql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是 否等于20。 

也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否 等于10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了。

### 执行器

开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如下所示。

```java
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的**引擎定义**，去使用这个引擎提供的**接口**。

比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的:

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中;
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

### 课后题

如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那 肯定是会报“不存在这个列”的错误: “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是 在我们上面提到的哪个阶段报出来的呢?

分析器，《高性能mysql》里提到解析器和预处理器。
解析器处理语法和解析查询, 生成一课对应的解析树。
预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。



问题：

1、引擎提供的接口什么样的。

2、select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20; 是不是先连接表。

## 02 | 日志系统：一条SQL更新语句时如何执行的

### redo log

MySQL中的WAL（Write Ahead Logging）技术，先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会把记录写到redo log，并更新内存，这个时候更新就算是完成了。InnoDB引擎会在适当的时候将这个操作记录到磁盘中。Redo log可以保证crash-safe。

InnoDB的redo log是固定大小的，一组4个文件。

![image-20220315105651948](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220315105651948.png)

write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。 checkpoint是要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

### binlog

MySQL整体可以分为两块，一块是Server层，一块是存储引擎层。redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog。binlog日志只能用于归档，没有crash-safe的能力。

binlog和redo log的不同

- redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用。
- redo log是物理日志，记录的是“在某个物理页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”。
- redo log是循环写入；binlog是可以追加写入的，不会覆盖之前的日志。

结合两种日志来看update语句的执行过程

```sql
update T set c = c + 1 where id = 2
```

1. 执行器先找引擎取ID=2这一行。如果ID=2这一 行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁盘读入内存，然 后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redolog处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交(commit)状态，更新完成。

![image-20220315112703547](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220315112703547.png)

### 两阶段提交

保证binlog 和redo log的一致性，用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语 句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash。

1. 假设在redo log写完，binlog还没有写完的时候，MySQL进程异 常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份 日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
2. 如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同。

根据两阶段提交，崩溃恢复时的判断规则是这样的：

如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交

如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整

- a. 如果 binlog 存在并完整，则提交事务;
- b. 否则，回滚事务。

### 数据恢复的过程

怎样让数据库恢复到半个月内任意一秒的状态？

前提：备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。

- 首先，找到最近的一次全量备份，从这个备份恢复到临时库; 
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到误删表之前的那个时刻。
- 此时临时库就跟误删之前的线上库一样了，然后把表数据从临时库取出来，按需要恢 复到线上库去。

## 03 | 事务隔离：为什么你改了我还看不见 

在MySQL中，事务支持是在引擎层实现的，不是所有的引擎都支持事务。

### 隔离性与隔离级别

数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题

读未提交，读已提交，可重复读（MySQL默认隔离级别），串行化

### 什么场景需要“可重复读”？

事务启动时的视图可以认为是静态的，不受其他事务 更新的影响。

### 事务隔离的实现

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

![image-20220316115616228](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220316115616228.png)

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看 到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多 个版本，就是数据库的多版本并发控制(MVCC)。对于read-view A，要得到1，就必须将当前 值依次执行图中所有的回滚操作得到。

回滚日志删除的时机，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。就是当系统里没有比这个回滚日志更早的read-view的时候。

**为什么尽量不要使用长事务：**

长事务意味着系统里会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

回滚段的影响，长事务还占用锁资源

### **事务的启动方式**

1、显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是 rollback。

2、set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

**使用set autocommit=1, 通过显式语句的方式来启动事务**

对于一个需要频繁使用事务的业务，第二种方式 每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。我建议你使用**commit work and chain**语法。

在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务

你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。

```mysql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 小结

事务隔离级别的现象和实现，长事务存在的风险，如何避免长事务。

## 04｜ 索引一

### 索引的常见模型

索引的出现是为了提高数据查询的效率，像树的目录一样。

索引的数据结构：

- 哈希表，是一种以（key-value）存储数据的结构，用一个哈希函数把key换算成一个

  确定的位置，然后把value放在数组的这个位置。

- 有序数组

  ![image-20220318091843422](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318091843422.png)

  这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。有序数组，在**等值查询**（二分）和**范围查询**（二分+向右遍历）场景中性能都非常优秀，但是，在需要更新数据往中间插入一个记录就必须得挪动后面所有的记录，成本太高。有序数组索引只适用于静态存储引擎，你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

- 搜素树

  平衡二叉树的插入和查询操作的复杂度O(log(N))

  二叉->多叉搜索树，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。树的高度和查询操作磁盘的I/O次数成正比。

  “N叉”树中的“N”取决于数据块的大小和索引字段的长度，以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存 1200的3次方个值，这已经17亿了。

### InnoDB的索引模型

```mysql
create table T( 
id int primary key, 
k int not null, 
name varchar(16), 
index(k))engine=InnoDB;
```

![image-20220318093637897](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318093637897.png)

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引(clustered index)。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引 (secondary index)。

非主键查询如果没有覆盖的话，需要回表查询。

### 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，需要逻辑上挪动后面的数据，空出位置。

如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的 数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，**性能**自然会受影响。页分裂操作还影响**数据页的利用率**。

数据库主键自增长的好处：

- 可以保证每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录
- 存储空间的角度，主键长度小，索引占用的空间也就越小

KV场景反映在索引上有两点：

- 只有一个索引
- 该索引必须是唯一索引

直接将这个索引设置为主键， 可以避免每次查询需要搜索两棵树。

### 思考题

```mysql
alter table T drop index k;
alter table T add index(k);
```

```mysql
alter table T drop primary key;
alter table T add primary key(id);
```

重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 : alter table T engine=InnoDB。

## 05 ｜ 索引二

![image-20220318162243022](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318162243022.png)

在上图所示的表中执行select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？

1. 在k索引树上找到k=3的记录，取得 ID = 300;
2. 再到ID索引树查到ID=300对应的R3;
3.  在k索引树取下一个值k=5，取得ID=500;
4.  再回到ID索引树查到ID=500对应的R4;
5. 在k索引树取下一个值k=6，不满足条件，循环结束。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录(步骤1、3和5)，回表了两次(步骤2和4)。

### 覆盖索引

```mysql
select ID from T where k between 3 and 5
```

需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5(对应的索引k 上的记录项)，但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL 认为扫描行数是2。

**在市民信息表上，是否有必要将身份证号和名字建立联合索引**

身份证号是市民的唯一标识，如果有根据身份证号查询市民信息的需求， 我们只要在身份证号字段上建立索引就够了。而再建立一个(身份证号、姓名)的联合索引，是不是浪费空间？如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。

### 最左前缀原则

![image-20220318163452013](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318163452013.png)

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是"where name like ‘张%’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历， 直到不满足条件为止。

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的**最左N个字段**，也可以是字符串索引的**最左M个字符**。

基于上面对最左前缀索引的说明，我们来讨论一个问题:在建立联合索引的时候，如何安排索 引内的字段顺序。

- 第一原则是，如果通过调整顺序，可 以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
- 我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段 大的 ，那我就建议你创建一个(name,age)的联合索引和一个(age)的单字段索引。

### 索引下推

市民表的联合索引（name, age）为例

```mysql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。

在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。

而MySQL 5.6 引入的索引下推优化(index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

**无索引下推的情况**

![image-20220318164935594](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318164935594.png)

**索引下推**

![image-20220318165028439](/Users/zhangyinze/Library/Application Support/typora-user-images/image-20220318165028439.png)

索引下推减少了回表的次数。

## 06 | 全局锁和表锁

锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问时，数据库需要合理地控制资源的访问规则。锁就是用来实现这些访问规则的重要数据结构。

MySQL里面的锁大致可以分为**全局锁**、**表级锁**和**行锁**三类。

### 全局锁

全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock(FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构）和更新类事务的提交语句。

**全局锁的典型使用场景是**，**做全库逻辑备份**。

以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。 注意，在备份过程中整个库完全处于只读状态。

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆;
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。



